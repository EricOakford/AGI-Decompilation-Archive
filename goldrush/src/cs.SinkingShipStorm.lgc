[***********************************************************[[ cs.SinkingShipStorm[[ This cutscene shows the ship sinking in stormy seas, after[ hitting an iceberg or rock, or after the boiler explosion.[ There are no interactions or player input allowed.[[***********************************************************[ **************************************[ LOCAL DEFINES[ **************************************#define oShip                        o1[ o2 is not used#define oWaves_1                     o3#define oWaves_2                     o4#define oWaves_3                     o5#define oLgSurf_1                    o6#define oLgSurf_2                    o7#define oLgSurf_3                    o8#define oSmSurf_1                    o9#define oSmSurf_2                   o10#define oSmSurf_3                   o11[ o12 is not used#define oDebris                     o13#define vIcebergTime                v81  [ override TripPoint_20#define vRockTime                   v82  [ override TripPoint_21#define vSinkStage                 v220[ v221 and v222 are not used#define vWaveTime                  v223#define vShipTimer                 v224#define vRndX                      v225#define vRndY                      v226#define vLgSurf_1                  v227#define vLgSurf_2                  v228#define vLgSurf_3                  v229#define vSmSurf_1                  v230#define vSmSurf_2                  v231#define vSmSurf_3                  v232[ v233 is not used#define vTmpVal                    v234#define vShipCel                   v235#define vSinkCounter               v236#define vTmpX                      v237#define vTmpY                      v238#define fShipSunk                  f220#define fLgSurfDone_1              f221#define fLgSurfDone_2              f222#define fLgSurfDone_3              f223#define fSmSurfDone_1              f224#define fSmSurfDone_2              f225#define fSmSurfDone_3              f226[ **************************************[ FIRST CYCLE ONLY[ **************************************if (isset(newRoom))  {    [ no input allowed in this room  prevent.input();    [ load the death handling logic  load.logics(lgc.DeathAtSea);    [ load picture for this room  load.pic(currentRoom);    [ load views used in the room  load.view(vw.SinkShip);  load.view(vw.SinkShipOnFire);  load.view(vw.SinkingShipArt);    [ load death sound  load.sound(m.Death2);    [ draw the current room picture  draw.pic(currentRoom);    [ the sinking ship  animate.obj(oShip);  [ if sinking due to rock or iceberg  if ((CurrentTripTime == vRockTime ||       CurrentTripTime == vIcebergTime))    {    [ use the non-burning view    set.view(oShip, vw.SinkShip);    }  else    {    [ if sinking due to fire, use the burning ship view    set.view(oShip, vw.SinkShipOnFire);    }  [ start with first cel of the loop  set.loop(oShip, 0);  set.cel(oShip, 0);  [ position ship in middle of screen  position(oShip, 53, 72);  set.priority(oShip, 8);  ignore.objs(oShip);  ignore.blocks(oShip);  [ draw it  draw(oShip);  [ begin cycling to show it sinking  end.of.loop(oShip, fShipSunk);  vTmpVal = 6;  cycle.time(oShip, vTmpVal);  [ begin with first stage of the sinking sequence  vSinkStage = 1;    [ waves  animate.obj(oWaves_1);  set.view(oWaves_1, vw.SinkingShipArt);  set.loop(oWaves_1, 0);  fix.loop(oWaves_1);  set.cel(oWaves_1, 0);  position(oWaves_1, 0, 167);  draw(oWaves_1);  vWaveTime = 2;  cycle.time(oWaves_1, vWaveTime);  start.cycling(oWaves_1);  [ second wave object, in middle of screen  animate.obj(oWaves_2);  set.view(oWaves_2, vw.SinkingShipArt);  set.loop(oWaves_2, 0);  fix.loop(oWaves_2);  set.cel(oWaves_2, 0);  position(oWaves_2, 53, 167);  ignore.objs(oWaves_2);  draw(oWaves_2);  vWaveTime = 2;  cycle.time(oWaves_2, vWaveTime);  start.cycling(oWaves_2);  [ third wave object, on right side  animate.obj(oWaves_3);  set.view(oWaves_3, vw.SinkingShipArt);  set.loop(oWaves_3, 0);  fix.loop(oWaves_3);  set.cel(oWaves_3, 0);  position(oWaves_3, 106, 167);  draw(oWaves_3);  vWaveTime = 2;  cycle.time(oWaves_3, vWaveTime);  start.cycling(oWaves_3);    [ large surf objects (don't draw yet)  animate.obj(oLgSurf_1);  set.view(oLgSurf_1, vw.SinkingShipArt);  set.loop(oLgSurf_1, 1);  fix.loop(oLgSurf_1);  set.cel(oLgSurf_1, 0);  ignore.objs(oLgSurf_1);  ignore.blocks(oLgSurf_1);  set.priority(oLgSurf_1, 9);  [ 2nd large surf  animate.obj(oLgSurf_2);  set.view(oLgSurf_2, vw.SinkingShipArt);  set.loop(oLgSurf_2, 1);  fix.loop(oLgSurf_2);  set.cel(oLgSurf_2, 0);  ignore.objs(oLgSurf_2);  ignore.blocks(oLgSurf_2);  set.priority(oLgSurf_2, 9);  [ third large surf  animate.obj(oLgSurf_3);  set.view(oLgSurf_3, vw.SinkingShipArt);  set.loop(oLgSurf_3, 1);  fix.loop(oLgSurf_3);  set.cel(oLgSurf_3, 0);  ignore.objs(oLgSurf_3);  ignore.blocks(oLgSurf_3);  set.priority(oLgSurf_3, 9);    [ small surf objects (don't draw yet)  animate.obj(oSmSurf_1);  set.view(oSmSurf_1, vw.SinkingShipArt);  set.loop(oSmSurf_1, 2);  fix.loop(oSmSurf_1);  set.cel(oSmSurf_1, 0);  ignore.objs(oSmSurf_1);  ignore.blocks(oSmSurf_1);  set.priority(oSmSurf_1, 9);  [ second small surf  animate.obj(oSmSurf_2);  set.view(oSmSurf_2, vw.SinkingShipArt);  set.loop(oSmSurf_2, 2);  fix.loop(oSmSurf_2);  set.cel(oSmSurf_2, 0);  ignore.objs(oSmSurf_2);  ignore.blocks(oSmSurf_2);  set.priority(oSmSurf_2, 9);  [ third small surf  animate.obj(oSmSurf_3);  set.view(oSmSurf_3, vw.SinkingShipArt);  set.loop(oSmSurf_3, 2);  fix.loop(oSmSurf_3);  set.cel(oSmSurf_3, 0);  ignore.objs(oSmSurf_3);  ignore.blocks(oSmSurf_3);  set.priority(oSmSurf_3, 9);    [ show the picture  show.pic();  }  [ **************************************[ EVERY CYCLE[ **************************************[ if at stage 2 of sinkingif (vSinkStage == 2)  {  [ get current cel of sinking ship  current.cel(oShip, vShipCel);  [ when ship gets to cel 6  if (vShipCel == 6)    {    [ advance to stage 3    vSinkStage = 3;    }  }  [ if at stage 3 of sinkingif (vSinkStage == 3)  {  [ in stage 3, the ship bobs in the water, alternating  [ between cels 5 and 6, while it slowly goes completely  [ under    [ increment timer  ++vShipTimer;  [ get current cel  current.cel(oShip, vShipCel);  [ after six cycles, when ship is at cel 5  if (vShipTimer == vTmpVal && vShipCel == 5)    {    [ reset timer, change to cel 6    vShipTimer = 0;    set.cel(oShip, 6);    }  [ after six cycles, when ship is at cel 6  if (vShipTimer == vTmpVal && vShipCel == 6)    {    [ reset timer, go back to cel 5    vShipTimer = 0;    set.cel(oShip, 5);    }  [ increment sink counter  ++vSinkCounter;  [ after 3 cycles  if (vSinkCounter == 3)    {    [ ship moves down and over one pixel    vTmpX = 1;    vTmpY = 1;    reposition(oShip, vTmpX, vTmpY);    vSinkCounter = 0;    }  else    {    [ on all other counts, ship just moves down one pixel    vTmpX = 0;    vTmpY = 1;    reposition(oShip, vTmpX, vTmpY);    }  }  [ when ship is completely under waterif (posn(oShip, 0, 128, 159, 128) && vSinkStage == 3)  {  [ advance to next stage  vSinkStage = 4;  [ change loop to show debris floating in the foam  set.loop(oDebris, 4);  set.cel(oDebris, 0);  [ run cycle one time  end.of.loop(oDebris, fShipSunk);  [ play sound  sound(m.Death2, DoneNoAction);  }  [ after debris cyclesif (isset(fShipSunk) && vSinkStage == 4)  {  [ advance to next stage  reset(fShipSunk);  vSinkStage = 5;  [ show only the debris  set.loop(oDebris, 5);  [ and let it cycle continuously  start.cycling(oDebris);  [ call logic to handle final details of the end  call(lgc.DeathAtSea);  }  [ if in first stage of sinkingif (vSinkStage == 1)  {  [ get current cel of the ship  current.cel(oShip, vShipCel);  [ when ship gets to cel 1  if (vShipCel == 1)    {    [ add the debris and foam around the sinking ship    animate.obj(oDebris);    set.view(oDebris, vw.SinkingShipArt);    [ show just the foam for now    set.loop(oDebris, 3);    fix.loop(oDebris);    position(oDebris, 80, 78);    set.priority(oDebris, 9);    draw(oDebris);    start.cycling(oDebris);    [ move to next stage    vSinkStage = 2;    }  }[ if large surf #1 not visibleif (vLgSurf_1 != 25)  {  [ random chance this surf will appear  random(20, 30, vLgSurf_1);  [ one in 11 chance  if (vLgSurf_1 == 25)    {    [ assign a random location    random(0, 142, vRndX);    random(92, 166, vRndY);    position.v(oLgSurf_1, vRndX, vRndY);    [ start at first cel    set.cel(oLgSurf_1, 0);    draw(oLgSurf_1);    [ cycle one time    end.of.loop(oLgSurf_1, fLgSurfDone_1);    }  }[ when large surf #1 is done cyclingif (isset(fLgSurfDone_1))  {  [ reset the flag  reset(fLgSurfDone_1);  [ remove surf from screen  erase(oLgSurf_1);  [ set status so it can randomly appear again  ++vLgSurf_1;  }  [ if large surf #2 not visibleif (vLgSurf_2 != 25)  {  random(20, 30, vLgSurf_2);  [ one in 11 chance  if (vLgSurf_2 == 25)    {    [ assign a random location    random(0, 142, vRndX);    random(92, 166, vRndY);    position.v(oLgSurf_2, vRndX, vRndY);    [ start at first cel    set.cel(oLgSurf_2, 0);    draw(oLgSurf_2);    [ cycle one time    end.of.loop(oLgSurf_2, fLgSurfDone_2);    }  }[ when large surf #2 is done cyclingif (isset(fLgSurfDone_2))  {  [ reset the flag  reset(fLgSurfDone_2);  [ remove surf from screen  erase(oLgSurf_2);  [ set status so it can randomly appear again  ++vLgSurf_2;  }[ if large surf #3 not visibleif (vLgSurf_3 != 25)  {  [ random chance this surf will appear  random(20, 30, vLgSurf_3);  [ one in 11 chance  if (vLgSurf_3 == 25)    {    [ assign a random location    random(0, 142, vRndX);    random(92, 166, vRndY);    position.v(oLgSurf_3, vRndX, vRndY);    [ start at first cel    set.cel(oLgSurf_3, 0);    draw(oLgSurf_3);    end.of.loop(oLgSurf_3, fLgSurfDone_3);    }  }[ when large surf #3 is done cyclingif (isset(fLgSurfDone_3))  {  [ reset the flag  reset(fLgSurfDone_3);  [ remove surf from screen  erase(oLgSurf_3);  ++vLgSurf_3;  }  [ if small surf #1 not visibleif (vSmSurf_1 != 25)  {  [ random chance this surf will appear  random(20, 30, vSmSurf_1);  [ one in 11 chance  if (vSmSurf_1 == 25)    {    [ assign a random location    random(0, 158, vRndX);    random(67, 86, vRndY);    position.v(oSmSurf_1, vRndX, vRndY);    [ start at first cel    set.cel(oSmSurf_1, 0);    draw(oSmSurf_1);    [ cycle one time    end.of.loop(oSmSurf_1, fSmSurfDone_1);    }  }[ when small surf #1 is done cyclingif (isset(fSmSurfDone_1))  {  [ reset the flag  reset(fSmSurfDone_1);  [ remove surf from screen  erase(oSmSurf_1);  [ set status so it can randomly appear again  ++vSmSurf_1;  }[ if small surf #2 not visibleif (vSmSurf_2 != 25)  {  [ random chance this surf will appear  random(20, 30, vSmSurf_2);  [ one in 11 chance  if (vSmSurf_2 == 25)    {    [ assign a random location    random(0, 158, vRndX);    random(67, 86, vRndY);    position.v(oSmSurf_2, vRndX, vRndY);    [ start at first cel    set.cel(oSmSurf_2, 0);    draw(oSmSurf_2);    [ cycle one time    end.of.loop(oSmSurf_2, fSmSurfDone_2);    }  }[ when small surf #2 is done cyclingif (isset(fSmSurfDone_2))  {  [ reset the flag  reset(fSmSurfDone_2);  [ remove surf from screen  erase(oSmSurf_2);  [ set status so it can randomly appear again  ++vSmSurf_2;  }  [ if small surf #3 not visibleif (vSmSurf_3 != 25)  {  [ random chance this surf will appear  random(20, 30, vSmSurf_3);  [ one in 11 chance  if (vSmSurf_3 == 25)    {    [ assign a random location    random(0, 158, vRndX);    random(67, 86, vRndY);    position.v(oSmSurf_3, vRndX, vRndY);    set.cel(oSmSurf_3, 0);    draw(oSmSurf_3);    [ cycle one time    end.of.loop(oSmSurf_3, fSmSurfDone_3);    }  }[ when small surf #3 is done cyclingif (isset(fSmSurfDone_3))  {  [ reset the flag  reset(fSmSurfDone_3);  [ remove surf from screen  erase(oSmSurf_3);  [ set status so it can randomly appear again  ++vSmSurf_3;  }  [ **************************************[ PROCESS PLAYER INPUT[ **************************************[ if player hasn't provided input no need to do said testsif (!isset(haveInput))  {  goto(Done);  }[ (this boilerplate 'if' block isn't needed since no input[ is processed in this cutscene logic)Done:return();[ **************************************[ MESSAGES[ **************************************